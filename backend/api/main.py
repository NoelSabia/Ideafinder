import logging
import asyncpg
import os
from contextlib import asynccontextmanager
from fastapi import FastAPI, status, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from dotenv import load_dotenv
from pydantic import BaseModel, EmailStr
from passlib.context import CryptContext

load_dotenv()

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)-8s - %(message)s')
logger = logging.getLogger(__name__)


@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Application startup...")
    db_user = os.getenv('POSTGRES_USER')
    db_password = os.getenv('POSTGRES_PASSWORD')
    db_name = os.getenv('POSTGRES_DB')
    db_host = os.getenv('POSTGRES_HOST', 'localhost')
    
    pool = None
    try:
        pool = await asyncpg.create_pool(
            user=db_user,
            password=db_password,
            database=db_name,
            host=db_host,
            port=5432
        )
        app.state.pool = pool
        logger.info("Database connection pool created.")

        async with pool.acquire() as connection:
            await connection.execute("""
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    name VARCHAR(255) NOT NULL,
                    email VARCHAR(255) UNIQUE NOT NULL,
                    password VARCHAR(255) NOT NULL,
                    problem_ids INTEGER[],
                    subscribed VARCHAR(50) DEFAULT 'inactive',
                    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
                )
            """)
        logger.info("Table 'users' initialized.")
        
        yield

    except Exception as e:
        logger.critical(f"Application startup failed: {e}")
        yield

    finally:
        logger.info("Application shutdown...")
        if pool:
            await pool.close()
            logger.info("Database connection pool closed.")


app = FastAPI(lifespan=lifespan)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class SignupBody(BaseModel):
    name: str
    email: EmailStr
    password: str

class LoginBody(BaseModel):
    email: EmailStr
    password: str


@app.post("/signup")
async def signup(request: Request, body: SignupBody) -> JSONResponse:
    pool = request.app.state.pool
    
    hashed_password = pwd_context.hash(body.password)

    async with pool.acquire() as connection:
        try:
            new_user_record = await connection.fetchrow(
                "INSERT INTO users (name, email, password) VALUES ($1, $2, $3) RETURNING *",
                body.name, body.email, hashed_password
            )
        except asyncpg.exceptions.UniqueViolationError:
            return JSONResponse(
                status_code=status.HTTP_409_CONFLICT,
                content={"message": f"User with email '{body.email}' already exists."}
            )

    if new_user_record:
        user_data = dict(new_user_record)
        user_data['created_at'] = user_data['created_at'].isoformat()
        del user_data['password']
        
        return JSONResponse(
            status_code=status.HTTP_201_CREATED,
            content={"user": user_data}
        )
    
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={"message": "User created, but failed to retrieve record."}
    )


@app.post("/login")
async def login(request: Request, body: LoginBody) -> JSONResponse:
    pool = request.app.state.pool

    async with pool.acquire() as connection:
        user_record = await connection.fetchrow(
            "SELECT * FROM users WHERE email = $1",
            body.email
        )

    if not user_record or not pwd_context.verify(body.password, user_record['password']):
        return JSONResponse(
            status_code=status.HTTP_401_UNAUTHORIZED,
            content={"message": "Invalid email or password."}
        )

    user_data = dict(user_record)
    del user_data['password']

    if user_data.get('created_at'):
        user_data['created_at'] = user_data['created_at'].isoformat()

    return JSONResponse(
        status_code=status.HTTP_200_OK,
        content={"user": user_data}
    )

@app.get("/health")
async def health(request: Request) -> JSONResponse:
    if hasattr(request.app.state, 'pool') and request.app.state.pool:
        try:
            async with request.app.state.pool.acquire() as connection:
                await connection.fetchval('SELECT 1')
            return JSONResponse(
                status_code=status.HTTP_200_OK,
                content={"status": "healthy", "database": "connected"}
            )
        except Exception:
             return JSONResponse(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                content={"status": "unhealthy", "database": "disconnected"}
            )
            
    return JSONResponse(
        status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
        content={"status": "unhealthy", "database": "pool_not_available"}
    )
